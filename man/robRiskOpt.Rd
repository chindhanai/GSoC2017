% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/robRiskOpt.R
\name{robRiskOpt}
\alias{robRiskOpt}
\title{Robust Risk Budgeting Optimization}
\usage{
robRiskOpt(riskBudgetObj, lower = 0, upper = 1, K = 100, maxit = 50,
  tol = 1e-05)
}
\arguments{
\item{riskBudgetObj}{a riskBidget object from \code{robRiskBudget} function}

\item{lower}{a numeric or vector of lower bounds \vec{\sigma^L} of risk budgets}

\item{upper}{a numeric or vector of upper bounds \vec{\sigma^L} of risk budgets}

\item{K}{a tuning factor for the iterative algorithm}

\item{maxit}{a number of maximum iterations}

\item{tol}{accuracy of the estimation with respect to the targeted volatility}
}
\value{
\code{robRiskOpt} returns a \code{list} containing the following objects:

\item{adjRiskBudget}{The vector of final risk budgets in each asset after the optimization}
\item{volatility}{The achieved volatility from the risk budgets}
\item{difference}{The difference between the achieved volatility and the targeted volatility}
\item{iterativeRiskBudget}{The matrix of risk budgets in each iteration columnwise}
\item{directedMat}{The matrix whose columns represent the vector of normalized distances in each iteration}
}
\description{
This function conmputes an optimal set of risk budgets that acheive a target level of volatility,
but with a lower expected shortfall.
}
\details{
This robust ooptimization algorithm takes into account both volatility and tail risk to create
a portfolio with a targeted level of volatility but with lower tail risk.
In the general case, and in the absence of any constraints, the risk budgets are given by

{\vec{\sigma} = \frac{{C}^{-1}}}{\sqrt{(IR)^T {C}^{-1} IR^}}\cdot \sigma_{Target}
where IR is the Information Ratio: IR = \frac{E[r]}{\sigma} and C is the correlation (not covariance) matrix
In general, it is extremely hard to allocate Expected Shortfall between strategies (or securities)in a way that
achievees a target level of Expected Shortfall for the portfolio. This algorithm finds a pragmatic middle way -
it allocates risk using volatility as the measure of risk, but uses Expected Shortfall to guide its allocations.
To do so, we start with the observaction that Information Ratio is a ratio of return to risk, and define tne
Modified Information Ratio {(IR^\prime) = \frac{E[r]}{\ES} } to be the ratio of Expected Return to Expected Shortfall.
For distributions that are characterized by a scale parameter, the Expected Shortfall will be a constant multiple of the
standard deviation, and the Modified Information Ratio is proportional to the Information Ratio.
{(IR^\prime) = \frac{E[r]}{ES}  = IR \cdot frac{{\sigma} {ES}} = frac{IR}{frac{{ES} {\sigma} }}    }. We call
{frac{{ES} {\sigma} }} the Tail Risk Ratio. we want to bias our risk budgets away from strategies or securiites with
high tail risk ratios, and towards startegies and securities with low tail risk ratios. We therefore make an ad-hoc
substitution and rewrite the expression for the risk budgets as follows:

{\vec{\sigma} = \frac{{C}^{-1}}}{\sqrt{(IR^\prime)^T {C}^{-1} IR^\prime}}\cdot \sigma_{Target}

in some risk budgeing applications, the various strategies / securities are only weakly correlated, and in these cases
the solution can be made even more robust by averaging the off-diagonal entries in the correlation matrix, so that

{\vec{\sigma} = \frac{\bar{C}^{-1}}}{\sqrt{(IR^\prime)^T \bar{C}^{-1} IR^\prime}}\cdot \sigma_{Target}

This simple closed form solution with the inclusion of tail risk and with a stabilized correlation matrix,
hardly ever results in negative solutions, and there is no need in practice to include
a long-only constraint - we just round up to 0 on the few occasionswhen a negative risk budget appears. However,
In the genenal case,if we want to bound \sigma_i between \sigma_i^U and \sigma_i^L, we either have to solve a full mean-
covariance optimization (and have to ignore the tail risk) or create a simulation based or historical optimization.
Instead, we can solve the problem using an approximate iterative scheme, with convergence in just one or two iterations
}
\examples{
data("RussellData")
RussellData = data
rf = RussellData[, 16]
robRiskData = RussellData[, 1:15]

riskBudget = robRiskBudget(robRiskData, rf = rf, shrink = TRUE, avgCor = TRUE,
                           ESMethod = "historical", corMatMethod = "mcd")

}
\author{
Thomas Phillips, Chindhanai Uthaisaad
}
